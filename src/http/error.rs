use std::borrow::Cow;

use http::StatusCode;

#[derive(Debug)]
pub struct BizError {
    pub biz_code: u32,
    pub http_status: StatusCode,
    pub message: Cow<'static, str>,
}

impl BizError {
    pub const fn new(http_status: u16, biz_code: u32, message: &'static str) -> Self {
        Self {
            biz_code,
            http_status: u16_to_status_code(http_status),
            message: std::borrow::Cow::Borrowed(message),
        }
    }

    pub fn with_context<T>(mut self, ctx: T) -> Self
    where
        T: AsRef<str>,
    {
        let msg = self.message.to_mut();
        msg.push_str(": ");
        msg.push_str(ctx.as_ref());

        self
    }
}

#[allow(non_upper_case_globals)]
impl BizError {
    pub const NoRequestBody: Self =
        Self::new(StatusCode::BAD_REQUEST.as_u16(), 100, "No request body");

    pub const InvalidRequestBody: Self = Self::new(
        StatusCode::BAD_REQUEST.as_u16(),
        101,
        "Invalid request body",
    );

    pub const InvalidJsonBody: Self =
        Self::new(StatusCode::BAD_REQUEST.as_u16(), 102, "Invalid json body");

    pub const InvalidQuery: Self =
        Self::new(StatusCode::BAD_REQUEST.as_u16(), 103, "Invalid query");
}

/// Convert u16 to http status code at compile time
///
/// Don't modify this function by hand as it was generated by a py script
pub const fn u16_to_status_code(code: u16) -> StatusCode {
    match code {
        100 => StatusCode::CONTINUE,
        101 => StatusCode::SWITCHING_PROTOCOLS,
        102 => StatusCode::PROCESSING,
        200 => StatusCode::OK,
        201 => StatusCode::CREATED,
        202 => StatusCode::ACCEPTED,
        203 => StatusCode::NON_AUTHORITATIVE_INFORMATION,
        204 => StatusCode::NO_CONTENT,
        205 => StatusCode::RESET_CONTENT,
        206 => StatusCode::PARTIAL_CONTENT,
        207 => StatusCode::MULTI_STATUS,
        208 => StatusCode::ALREADY_REPORTED,
        226 => StatusCode::IM_USED,
        300 => StatusCode::MULTIPLE_CHOICES,
        301 => StatusCode::MOVED_PERMANENTLY,
        302 => StatusCode::FOUND,
        303 => StatusCode::SEE_OTHER,
        304 => StatusCode::NOT_MODIFIED,
        305 => StatusCode::USE_PROXY,
        307 => StatusCode::TEMPORARY_REDIRECT,
        308 => StatusCode::PERMANENT_REDIRECT,
        400 => StatusCode::BAD_REQUEST,
        401 => StatusCode::UNAUTHORIZED,
        402 => StatusCode::PAYMENT_REQUIRED,
        403 => StatusCode::FORBIDDEN,
        404 => StatusCode::NOT_FOUND,
        405 => StatusCode::METHOD_NOT_ALLOWED,
        406 => StatusCode::NOT_ACCEPTABLE,
        407 => StatusCode::PROXY_AUTHENTICATION_REQUIRED,
        408 => StatusCode::REQUEST_TIMEOUT,
        409 => StatusCode::CONFLICT,
        410 => StatusCode::GONE,
        411 => StatusCode::LENGTH_REQUIRED,
        412 => StatusCode::PRECONDITION_FAILED,
        413 => StatusCode::PAYLOAD_TOO_LARGE,
        414 => StatusCode::URI_TOO_LONG,
        415 => StatusCode::UNSUPPORTED_MEDIA_TYPE,
        416 => StatusCode::RANGE_NOT_SATISFIABLE,
        417 => StatusCode::EXPECTATION_FAILED,
        418 => StatusCode::IM_A_TEAPOT,
        421 => StatusCode::MISDIRECTED_REQUEST,
        422 => StatusCode::UNPROCESSABLE_ENTITY,
        423 => StatusCode::LOCKED,
        424 => StatusCode::FAILED_DEPENDENCY,
        426 => StatusCode::UPGRADE_REQUIRED,
        428 => StatusCode::PRECONDITION_REQUIRED,
        429 => StatusCode::TOO_MANY_REQUESTS,
        431 => StatusCode::REQUEST_HEADER_FIELDS_TOO_LARGE,
        451 => StatusCode::UNAVAILABLE_FOR_LEGAL_REASONS,
        500 => StatusCode::INTERNAL_SERVER_ERROR,
        501 => StatusCode::NOT_IMPLEMENTED,
        502 => StatusCode::BAD_GATEWAY,
        503 => StatusCode::SERVICE_UNAVAILABLE,
        504 => StatusCode::GATEWAY_TIMEOUT,
        505 => StatusCode::HTTP_VERSION_NOT_SUPPORTED,
        506 => StatusCode::VARIANT_ALSO_NEGOTIATES,
        507 => StatusCode::INSUFFICIENT_STORAGE,
        508 => StatusCode::LOOP_DETECTED,
        510 => StatusCode::NOT_EXTENDED,
        511 => StatusCode::NETWORK_AUTHENTICATION_REQUIRED,
        _ => panic!("invalid http status code"),
    }
}

impl std::fmt::Display for BizError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "code = {}, msg ={}", self.biz_code, self.message)
    }
}

#[derive(Debug, derive_more::From)]
pub enum HttpError {
    Biz(BizError),
    Anyhow(anyhow::Error),
}

impl std::fmt::Display for HttpError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            HttpError::Biz(biz_error) => write!(f, "{}", biz_error),
            HttpError::Anyhow(error) => write!(f, "{}", error),
        }
    }
}

impl HttpError {
    pub fn biz_code(&self) -> u32 {
        match self {
            HttpError::Biz(biz_error) => biz_error.biz_code,
            HttpError::Anyhow(_) => 1,
        }
    }

    pub fn message(&self) -> Cow<'static, str> {
        match self {
            HttpError::Biz(biz_error) => biz_error.message.clone(),
            HttpError::Anyhow(error) => Cow::Owned(format!("{:?}", error)),
        }
    }
}

#[cfg(feature = "actix-web")]
mod actix_impl {
    use actix_web::ResponseError;

    use crate::http::response::{DataOrError, HttpResponseBodyTemplate};

    use super::{BizError, HttpError};

    impl ResponseError for HttpError {
        fn status_code(&self) -> actix_web::http::StatusCode {
            let status_code = match self {
                HttpError::Biz(biz_error) => biz_error.http_status,
                HttpError::Anyhow(_) => {
                    return actix_web::http::StatusCode::INTERNAL_SERVER_ERROR;
                }
            };
            actix_web::http::StatusCode::from_u16(status_code.as_u16()).unwrap()
        }

        fn error_response(&self) -> actix_web::HttpResponse<actix_web::body::BoxBody> {
            let mut res = actix_web::HttpResponse::build(self.status_code());
            let body = HttpResponseBodyTemplate {
                code: self.biz_code(),
                body: DataOrError::<()>::Error(self.message()),
            };

            res.json(body)
        }
    }

    impl ResponseError for BizError {
        fn status_code(&self) -> actix_web::http::StatusCode {
            actix_web::http::StatusCode::from_u16(self.http_status.as_u16()).unwrap()
        }

        fn error_response(&self) -> actix_web::HttpResponse<actix_web::body::BoxBody> {
            let mut res = actix_web::HttpResponse::build(self.status_code());
            let body = HttpResponseBodyTemplate {
                code: self.biz_code,
                body: DataOrError::<()>::Error(self.message.clone()),
            };

            res.json(body)
        }
    }
}
